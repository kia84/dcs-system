/* encoding: UTF-8 */

/** hash.h, Ivan Korunkov, 2012 **/

/**
    Здесь объявлены функции, позволяющие работать с хэшами в языке Си.
    В данной реализации и ключ и значение - это строки.
    Значения, хранимые в хэше - md5-суммы, отсюда длина значения 32 B.
    Проблема коллизий решается с помощью метода цепочек, т.е.
    каждый элемент - это начало L1 списка.
    Размер хэш-таблицы должен соответствовать степени двойки (подробнее ниже).
    Поддерживается саморасширение хэш-таблицы (подробнее ниже).
**/

#ifndef	_HASH_H
#define _HASH_H

#include <stdint.h>    /* Содержит uint32_t и т.п. */

#include "hash_func.h"

#define HASH_ELEMENT_KEY_SIZE 40    /* Максимальная длина ключа   */
#define HASH_ELEMENT_VAL_SIZE 16    /* Длина значения (md5-сумма) */

/*
    Так как размер хэш-таблицы должен соответствовать степени двойки,
    при инициализации нужно указывать не сам размер, а требуюмую степень,
    для исключения ошибок на этом этапе.
    При этом, можно задать "размер по-умолчанию", указав при вызове функции
    Hash_init отрицательную степень двойки.
    Степень применяемая по-умоланию объявляется через DEFAULT_HASH_TABLE_POW2.
    
    Конечный размер хэш-таблицы, считается с помощью директивы hashsize(),
    объявленной в hash_func.h
*/
#define DEFAULT_HASH_TABLE_POW2       10

/*
    Для более грамотного распределения ключей по массиву (хэш-таблице)
    хэш-функция может принимать некое число, задающее начальный сдвиг
    возвращаемого значения. По умолчанию это число (стартовое значение)
    равно нулю. Объявлять любые другие константы смысла не имеет, т.к.
    стартовое значение должно меняться от элемента к элементу.
    DEFAULT_INITVAL призван получать стартовое значение по ключу,
    и используется в функциях добавления, поиска, и т.д.
    DEFAULT_INITVAL может быть, например, таким: (key[0]).
*/
#define DEFAULT_INITVAL(key)            0

/*
    Если AUTO_EXPAND не равен 0, хэшу разрешается автоматически увеличивать
    размер хэш-таблицы в два раза, при слишком большом коэффициенте заполнения.
    Коэффициент заполнения рассчитывается по формуле:
        load_factor = elements_count / hash_table_size
    Где:
        load_factor     - коэффициент заполнения
        elements_count  - количество пар ключ-значение в хэш-таблице
        hash_table_size - размер хэш-таблицы
    
    Размер хэш-таблицы увеличивается тогда, когда
    load_factor > MAXIMUM_HASH_TABLE_LOAD_FACTOR.
    
    Проверка выполняется при добавлении очередного элемента.
    
    В случае, если данная возможность не требуется, и за состоянием хэша будут
    следить вручную, установите AUTO_EXPAND в 0.
    Однако при каждом запуске Hash_expand всё равно будет производиться
    сравнение с MAXIMUM_HASH_TABLE_LOAD_FACTOR, так как операция расширения
    достаточно ресурсоёмкая, и должна производиться только при необходимости.
*/
#ifndef AUTO_EXPAND
    #define AUTO_EXPAND 1
#endif

/*
    MAXIMUM_HASH_TABLE_LOAD_FACTOR - число, отвечающее за расширение
    хэш-таблицы. Численно равно максимальному отношению количества
    записей к размеру хэш-таблицы, при превышении которого возможно
    расширение.
    Подробнее в разделе AUTO_EXPAND.
*/
#define MAXIMUM_HASH_TABLE_LOAD_FACTOR 0.46    /* 0...1 */

/*
    Для корректной работы хэша, введено ограничение на максимальный размер
    хэш-таблицы (а конкретно, степени двойки), так как иначе может настать
    момент, когда хэш-таблица просто перестанет помещаться в памяти.
    Вычислить максимальный размер хэш-таблицы можно по прилагаемым формулам.
    После того, как степень достигнет MAXIMUM_HASH_TABLE_POW2, расширение
    хэш-таблицы будет невозможно.
*/
#define MAXIMUM_HASH_TABLE_POW2        21

/* Как рассчитать размер хэш-таблицы в памяти
    TABLE_SIZE               = 4 * (2 ** HASH.power2) B
    TABLE_SIZE_WITH_ELEMENTS = TABLE_SIZE * 
        (8 + HASH_ELEMENT_KEY_SIZE + HASH_ELEMENT_VAL_SIZE) B
*/

/* Таблица возможных размеров хэш-таблицы

    COUNT_OF_ELEMENTS - количество элементов в массиве
    TABLE_SIZE        - размер пустой хэш-таблицы в ОП
    WITH_ELEMENTS     - размер полностью заполненной таблицы

    COUNT_OF_ELEMENTS    | TABLE_SIZE | WITH_ELEMENTS(x * 64)
  -----------------------+------------+------------------------
    2 **  0 = 1          |  4   B     | 256 B
    2 **  1 = 2          |  8   B     | 512 B
    2 **  2 = 4          |  16  B     | 1   KB
    2 **  3 = 8          |  32  B     | 2   KB
    2 **  4 = 16         |  64  B     | 4   KB
    2 **  5 = 32         |  128 B     | 8   KB
    2 **  6 = 64         |  256 B     | 16  KB
    2 **  7 = 128        |  512 B     | 32  KB
    2 **  8 = 256        |  1   KB    | 64  KB
    2 **  9 = 512        |  2   KB    | 128 KB _
    2 ** 10 = 1024       |  4   KB    | 256 KB  \
    2 ** 11 = 2048       |  8   KB    | 512 KB  |
    2 ** 12 = 4096       |  16  KB    | 1   MB  |
    2 ** 13 = 8192       |  32  KB    | 2   MB  |
    2 ** 14 = 16384      |  64  KB    | 4   MB  |
    2 ** 15 = 32768      |  128 KB    | 8   MB   > NORMAL RANGE
    2 ** 16 = 65536      |  256 KB    | 16  MB  |
    2 ** 17 = 131072     |  512 KB    | 32  MB  |
    2 ** 18 = 262144     |  1   MB    | 64  MB  |
    2 ** 19 = 524288     |  2   MB    | 128 MB  |
    2 ** 20 = 1048576    |  4   MB    | 256 MB _/
    2 ** 21 = 2097152    |  8   MB    | 512 MB
    2 ** 22 = 4194304    |  16  MB    | 1   GB
    2 ** 23 = 8388608    |  32  MB    | 2   GB
    2 ** 24 = 16777216   |  64  MB    | 4   GB
    2 ** 25 = 33554432   |  128 MB    | 8   GB
    2 ** 26 = 67108864   |  256 MB    | 16  GB
    2 ** 27 = 134217728  |  512 MB    | 32  GB
    2 ** 28 = 268435456  |  1   GB    | 64  GB
    2 ** 29 = 536870912  |  2   GB    | 128 GB
    2 ** 30 = 1073741824 |  4   GB    | 256 GB
    2 ** 31 = 2147483648 |  8   GB    | 512 GB
    2 ** 32 = 4294967296 |  16  GB    | 1   TB
*/

/*~~~~~~~~~~~~~~~~~~~~~~~~ Коды возвращаемых ошибок ~~~~~~~~~~~~~~~~~~~~~~~~*/
/*  При вызове функций *alloc() ошибка - не хватает памяти.                 */
#define HASH_ERROR_NO_MEMORY       -1
/*  Попытка расширения хэш-таблицы закончилась неудачей - слишком малый
    коэффициент заполнения - расширение не имеет смысла.
    (load_factor <= MAXIMUM_HASH_TABLE_LOAD_FACTOR)                         */
#define HASH_ERROR_LOW_LOADFACT    -2
/* Попытка расширения хэш-таблицы закончилась неудачей - достигнута
   максимально высокая степень двойки. (MAXIMUM_HASH_TABLE_POW2)            */
#define HASH_ERROR_HIGH_POW2       -3
/*~~~~~~~~~~~~~~~~~~~~~~~ /Коды возвращаемых ошибок ~~~~~~~~~~~~~~~~~~~~~~~~*/

/*
    Данная структура определяет элемент хэша. Содержит в себе ключ и значение.
    Во избежание потери данных при возникновении коллизий, каждый элемент
    является началом L1 списка. Поэтому в его структуре также содержится
    указатель на следующий элемент (при его наличии, либо NULL).
    
    Вручную можно менять только val. Если хотите поменять ключ - удалите
    текущий элемент, и создайте новый, с новым ключом, с помощью функций
    Hash_remove_element и Hash_insert.
*/
typedef struct HashL1E {
    char key[HASH_ELEMENT_KEY_SIZE + 1];    /* + '\0' */
    char val[HASH_ELEMENT_VAL_SIZE];
    struct HashL1E *next;
} HASH_ELEMENT;

/*
    Структура, определяющая хэш как сущность.
    Содержит в себе указатель на хэш-таблицу (массив элементов), а также
    фактический размер таблицы, степень двойки, по которой был получен
    размер, и текущее количество элементов в хэш-таблице.
    Таким образом можно посчитать коэффициент заполнения (См. AUTO_EXPAND).
    load_factor = elem_count / table_size.
    Все поля этой структуры заполняются автоматически.
    Никогда не меняйте их напрямую, без использования нижеследующих функций.
*/
typedef struct {
    HASH_ELEMENT **hash_table;
    uint32_t       table_size;
    uint32_t       elem_count;
    unsigned int   power2;
} HASH;

/*  Hash_init
    Функция, производящая первичную инициализацию хэша.
    
    HASH *new_hash - указатель на структуру типа HASH, которую необходимо
        инициализировать.
        
    int pow_2      - число - степень двойки, по которому будет вычислен
        размер хэш-таблицы.
    
    Если при вызове функции в качестве степени двойки передать (-1)
    размер хэш-таблицы будет установлен по-умолчанию.
    Подробнее см. DEFAULT_HASH_TABLE_POW2.
    
    ВНИМЕНИЕ: функция Hash_init вызывает calloc для создания хэш-таблицы.
    Для избежания утечек памяти, после работы с хэшем обязательно
    используйте Hash_destroy.
    
    Не используйте Hash_init более одного раза подряд для одного и того же
    хэша, без вызова Hash_destroy.
    
    Возвращает 0 если всё прошло успешно, либо HASH_ERROR_NO_MEMORY при
    ошибке выделения памяти (точный код ошибки находится в ERRNO).
*/
int  Hash_init(HASH *new_hash, int pow_2);

/*  Hash_destroy
    Функция, производящая освобождение занятой хэшем памяти.
    Сбрасывает все установленные в структуре HASH поля.
    
    Единственный аргумент - указатель на существующий хэш.
*/
void Hash_destroy(HASH *exists_hash);

/*  Hash_expand
    Функция, проверяющая необходимость расширения хэш-таблицы, и выполняющая
    расширение, если это нужно. При расширении размер таблицы увеличивается
    в два раза.
    
    Единственный аргумент - указатель на существующий хэш.
    
    Возвращает:
        0 - если таблица успешно расширена;
        HASH_ERROR_LOW_LOADFACT - если расширение не целесообразно, то-есть
            коэффициент загруженности слишком мал
            (load_factor <= MAXIMUM_HASH_TABLE_LOAD_FACTOR);
        HASH_ERROR_HIGH_POW2 - если расширение невозможно по причине
            достижения максимального значения степени двойки, по которой
            вычисляется размер таблицы.
    
    Для доп. информации смотрите также:
        AUTO_EXPAND,
        MAXIMUM_HASH_TABLE_LOAD_FACTOR,
        MAXIMUM_HASH_TABLE_POW2.
*/
int  Hash_expand(HASH *exists_hash);

/*  Hash_insert
    Функция, добавляющая в хэш новую пару [ключ -> значение].
    Если такой ключ уже существует, его значение будет перезаписано.
    
    Аргументы:
        HASH       *exists_hash - указатель на существующий хэш;
        const char *new_key     - ключ;
        size_t      key_length  - длина ключа;
        const char *new_val     - значение (md5-сумма);
        size_t      val_length  - длина значения.
    
    Возвращает указатель на только что созданный элемент в случае успеха,
    или NULL при возникновении ошибки выделения памяти, или некорректных
    размерах строк (точный код ошибки находится в ERRNO).
    
    В случае, если длина ключа или значения больше чем
    HASH_ELEMENT_KEY_SIZE или HASH_ELEMENT_VAL_SIZE
    соответственно, функция возвращает NULL и выставляет errno в EINVAL.
*/
HASH_ELEMENT *Hash_insert(
        HASH       *exists_hash,
        const char *new_key,
        size_t      key_length,
        const char *new_val,
        size_t      val_length
    );

/*  Hash_find
    Функция поиска по хэшу.
    
    Аргументы:
        HASH       *exists_hash - указатель на существующий хэш;
        const char *key         - ключ;
        size_t      key_length  - длина ключа.
    
    Возвращает указатель на найденный элемент в случае успеха, или NULL,
    если элемент не найден, или передан некорректный ключ.
    В случае, если длина ключа больше, чем HASH_ELEMENT_KEY_SIZE
    функция возвращает NULL и выставляет errno в EINVAL.
*/
HASH_ELEMENT *Hash_find(
        HASH       *exists_hash,
        const char *key,
        size_t      key_length
    );

/*  Hash_remove_element
    Функция удаляющая элемент по ключу.
    
    Аргументы:
        HASH       *exists_hash - указатель на существующий хэш;
        const char *key         - ключ;
        size_t      key_length  - длина ключа.
    
    Функция не вернёт ошибку, даже если передать несуществующий ключ.
    
*/
void Hash_remove_element(
        HASH       *exists_hash,
        const char *key,
        size_t      key_length
    );

#endif /* hash.h */
